Terms:

Set
    - A data structure that will never contain any duplicate values.
    - It can only contain iterables (array being the most common use, but strings work too).
    - A set is an iterable, so it can be spread (unpacked and listed out comma seperated).
    - If you need to manipulate data, or the data order matters, sets are not the best use-case and an array would be better suited
    - CRUD methods on a set? EXPLAIN.
        - .add() -- Also returns the set, so you can chain .add() methods
        - .has(), .delete(), .clear()
    - Useful properties?
        - .size -- similar to .length on an array
    - Converting a set to an array and vice versa?

Map
    - A data structure similar to an object, but keys can be any data type (boolean, object, array, number, etc.)
    - CRUD methods on a map? EXPLAIN.
        - .set(key, value) -- Also returns the map, so you can chain .set() methods
        - .has(), .delete(), .get(), clear()
    - Useful properties?
        - .size -- similar to .length on an array
    - Converting a map to an object and vice versa?

.pop()
    - Deletes the last element in an array AND returns that element's value (can be useful if you just need the value of the last element)

Immutable types
    - Primitive types are immutable because they are typed by value rather than by reference

.slice()
    - Start parameter stays in, end parameter is cut.
        - '0123456789'.slice(1, 8) => // '1234567'
        - '0123456789'.slice(0, -5) => // '01234'
    - If end parameter is omitted, it will take the start parameter and keep everything after
        - '0123456789'.slice(6) => // '6789'
        - '0123456789'.slice(-2) => // '89'

How can strings have methods if they are primitives and not objects?
    - When you invoke any string method (.slice(), .indexOf(), etc.) or even access an index with bracket notation ('thomas'[0]), JavaScript is actually converting the string into an object (new String('string')), and it is on that object that the method is attached and being invoked from. After the execution of the method, it is converted back into a primitive string and returned, because primitives cannot be mutated.




















    function changeObject(x) {
  x = { member: 'bar' };
  console.log('in changeObject: ' + x.member);
}

function changeMember(x) {
  x.member = 'bar';
  console.log('in changeMember: ' + x.member);
}

var x = { member: 'foo' };

console.log('before changeObject: ' + x.member);
changeObject(x);
console.log('after changeObject: ' + x.member); /* change did not persist */

console.log('before changeMember: ' + x.member);
changeMember(x);
console.log('after changeMember: ' + x.member); /* change persists */