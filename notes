Terms:

Set
    - A data structure that will never contain any duplicate values.
    - It can only contain iterables (array being the most common use, but strings work too).
    - A set is an iterable, so it can be spread (unpacked and listed out comma seperated).
    - If you need to manipulate data, or the data order matters, sets are not the best use-case and an array would be better suited
    - CRUD methods on a set? EXPLAIN.
        - .add() -- Also returns the set, so you can chain .add() methods
        - .has(), .delete(), .clear()
    - Useful properties?
        - .size -- similar to .length on an array
    - Converting a set to an array and vice versa?

Map
    - A data structure similar to an object, but keys can be any data type (boolean, object, array, number, etc.)
    - CRUD methods on a map? EXPLAIN.
        - .set(key, value) -- Also returns the map, so you can chain .set() methods
        - .has(), .delete(), .get(), clear()
    - Useful properties?
        - .size -- similar to .length on an array
    - Converting a map to an object and vice versa?

.pop()
    - Deletes the last element in an array AND returns that element's value (can be useful if you just need the value of the last element)

Immutable types vs Mutable types (and assignment)
    - Primitive types are immutable because they are typed by value.
        - You cannot take a primitive and change it's value, you can however, reassign it.
        - If you reassign a primitive, you will simply point to a new address, rather than changing the original one.
    - Objects are mutable because they are typed by reference.
        - You can take an object and change it's value by reassigning it's properties or adding/deleting elements.

Compare by value vs by reference

.slice()
    - Start parameter stays in, end parameter is cut.
        - '0123456789'.slice(1, 8) => // '1234567'
        - '0123456789'.slice(0, -5) => // '01234'
    - If end parameter is omitted, it will take the start parameter and keep everything after
        - '0123456789'.slice(6) => // '6789'
        - '0123456789'.slice(-2) => // '89'

How can strings have methods if they are primitives and not objects?
    - When you invoke any string method (.slice(), .indexOf(), etc.) or even access an index with bracket notation ('thomas'[0]), JavaScript is actually converting the string into an object (new String('string')), and it is on that object that the method is attached and being invoked from. After the execution of the method, it is converted back into a primitive string and returned, because primitives cannot be mutated.

String methods:
    - indexOf, lastIndexOf, firstIndexOf
    - []
    - replace
    - join, split
    - slice
    - toUpperCase, toLowerCase
    - trim, trimLeft, trimRight
    - padStart, padEnd
    - repeat

Instantiate vs Initialize

Const(ant) vs read-only

Default function arguments (and using expressions in them)

First-Class Functions

Higher-Order Functions

Callback Functions

Abstraction (levels of abstraction)


























// Function to replace a character in a string at a particular index with a different character
const replaceAt = function (str, index, replacement) {
  const end = str.slice(index);
  const replaced = end.replace(end[0], replacement);
  return str.slice(0, index) + replaced;
};


















    function changeObject(x) {
  x = { member: 'bar' };
  console.log('in changeObject: ' + x.member);
}

function changeMember(x) {
  x.member = 'bar';
  console.log('in changeMember: ' + x.member);
}

var x = { member: 'foo' };

console.log('before changeObject: ' + x.member);
changeObject(x);
console.log('after changeObject: ' + x.member); /* change did not persist */

console.log('before changeMember: ' + x.member);
changeMember(x);
console.log('after changeMember: ' + x.member); /* change persists */